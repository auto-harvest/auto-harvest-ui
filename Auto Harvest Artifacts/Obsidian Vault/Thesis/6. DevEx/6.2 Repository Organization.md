The Auto Harvest project is divided into two separate codebases to keep things organized and easy to manage. One repository is used for the **mobile/web app (frontend)**, and the other is a **monorepo** that includes both the **backend services** and the **firmware** used in the hardware.

#### **Frontend Repository**

The mobile app is built using **React Native** with **Expo** and written in **TypeScript**. The code is organized into different folders such as components, screens, Redux state files, utility functions, and assets. The app uses **`expo-router`** for navigation, which automatically handles screen routing based on the folder structure.

For state management, the app uses **Redux Toolkit** and `redux-persist` to store data locally. Several native libraries are also used, including `react-native-wifi-reborn` for managing Wi-Fi connections, and other Expo modules for device features like location and haptics. The project also uses tools like ESLint for code quality and Jest for testing. This structure helps keep the codebase clean, scalable, and easy to work with.

#### **Backend and Firmware Monorepo**

The second repository uses **Nx**, a monorepo tool that allows multiple apps and libraries to be managed in the same workspace. This repo contains:

- `apps/api/report-server`: A backend service built with **Express.js**, using **MongoDB** with Mongoose, and **ActiveMQ** for handling message queues.
    
- `apps/frontend/tester`: A small React app used internally for testing and checking backend features.
    
- `apps/iot/io-manager`: A **PlatformIO** project used to write and upload firmware for the **ATMEGA2560** microcontroller and **ESP-01** Wi-Fi module.
    

The backend and tester projects are managed using Nx plugins, while the firmware is handled using the **PlatformIO plugin in VS Code**, which helps with building, uploading, monitoring serial output, and installing libraries. Even though the backend and firmware donâ€™t share code directly, working with them side by side in the same workspace makes testing and development easier, especially when checking how the microcontroller sends data and how the backend receives it.

This setup allows developers to easily switch between mobile, backend, and firmware development, improving the workflow and making the system easier to maintain and expand.