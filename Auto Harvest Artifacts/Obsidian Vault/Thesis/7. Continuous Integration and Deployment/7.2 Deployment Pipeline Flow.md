## Deployment Strategy

The Auto Harvest project follows a streamlined deployment process designed for **speed, reliability, and future scalability**. While the CI/CD workflow (Section 7.2) handles build automation and validation, the deployment strategy defines how new code moves safely from development to production and how environments are managed over time.

---

### üåø Branch Strategy

The repository follows a **trunk-based development model** supported by three branches:

- **`dev`**: Used for development testing. Docker images are built with a `dev` tag and validated within a **local Kubernetes cluster**.
    
- **`stage`**: Reserved for future use with a dedicated staging namespace or cluster. Currently inactive.
    
- **`main`**: The production branch. All merges to `main` must pass a pull request review and trigger a **full deployment pipeline** to Google Kubernetes Engine (GKE).
    

This structure enforces **code quality gates** (reviews, CI checks) before production changes are accepted, balancing rapid iteration with stability.

---

### üîÅ Automated Production Deployments

Merges to `main` initiate an automated release that:

1. Builds and pushes Docker images for affected backend services.
    
2. Updates Kubernetes Deployments with the new image tag.
    

This automation ensures production is always updated in a consistent and reproducible manner. Frontend releases are currently managed through manual uploads and helper scripts (see Section 7.3) but will later be integrated into the same automated flow.

---

### üì¶ Environments and Namespacing

At present, Auto Harvest operates in a **single production environment**. However, the Kubernetes cluster is configured to support **namespaced deployments**, providing a path to scale into:

- A **shared staging namespace** within the existing cluster.
    
- A **separate staging cluster** for stricter isolation once required.
    

This flexibility allows the system to evolve without restructuring the core deployment logic.

---

### üîô Rollback Strategy

In the event of a faulty release, rollbacks are performed manually via:

`kubectl set image deployment/<service-name> <container-name>=<previous-image-digest>`

This mechanism uses immutable image digests stored in Artifact Registry, enabling precise reversions of individual services. Future enhancements will add deployment history, Slack or dashboard notifications, and simplified rollback tooling (e.g., a CLI helper or one-click action in the admin interface).

---

### ‚úÖ Observability and Status

Deployment health is currently monitored through:

- **GitHub Actions logs** (per commit/PR).
    
- **Google Cloud Console dashboards** for GKE and Artifact Registry.
    
- Basic Kubernetes commands (`kubectl get pods`, `kubectl describe`).
    

Planned integration with **Cloud Monitoring** will provide unified dashboards for deployment success, service health, and resource usage over time.

---

This revised section **avoids re-explaining authentication, caching, and secrets management** (already covered in CI/CD), while emphasizing **branching, environment management, rollback, and observability** ‚Äî the higher-level deployment concerns.