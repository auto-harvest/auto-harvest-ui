While the previous section focused on the structural organization of the firmware, this section highlights its intelligent runtime behavior and the way architectural components are utilized in practice.

Beyond basic sensor polling and device connectivity, the firmware is designed to exhibit **intelligent behavior** ‚Äî automating safety decisions, responding to commands, and controlling modules in a state-aware manner. These features make the device not just reactive but **proactive**, adding real value in unattended environments like hydroponic farms.

---

### üß† Smart Timers and System Loop

Three primary timers coordinate the firmware's runtime operations:

| Timer             | Function                         | Interval  |
| ----------------- | -------------------------------- | --------- |
| `sensorPollTimer` | Reads data from all sensors      | 2 seconds |
| `dataSendTimer`   | Publishes collected data to MQTT | 5 seconds |
| `lcdUpdateTimer`  | Rotates LCD screen contents      | 1 second  |

Each timer checks `.expired()` inside the `loop()` and triggers its associated behavior without blocking the main thread. This ensures **responsive multitasking** ‚Äî a necessity for sensor-heavy embedded systems.

---

### üö® Device-Side Fault Detection

One of the most critical custom behaviors is **safety logic** built into the firmware itself. A key implementation is in the `DataCollector` service, where it performs the following:

#### üõë Pump Flow Verification

If:

- The **water pump is active**, and
    
- The **flow sensor detects no pulses**
    

‚Üí The firmware will:

- Deactivate the pump (relay off)
    
- Push a warning log to MQTT
    
- Display the event on the LCD queue (`"No water detected!"`)
    

This local safeguard prevents pump burnout and allows the system to **act independently of cloud latency or outages**.

---

### üì° MQTT Command Routing

The firmware listens to a configurable MQTT topic for incoming device commands. When received, commands are enqueued and processed in the loop.

Supported commands include:

|Command|Behavior|
|---|---|
|`pump-on`|Turns the water pump ON (via relay)|
|`air-pump-off`|Deactivates the air pump|
|`set-sensor-poll-interval`|Dynamically changes poll rate|
|`turn-to-ap`|Reboots into Wi-Fi pairing mode|
|`connect-to-wifi`|Connects to provided SSID/PW|
|`lcd-on/lcd-off`|Toggles the display power|

This design separates **message parsing from execution**, and allows reliable replaying if a connection is temporarily lost.

---

### üßæ LCD Carousel and Message Queue

The `LCDModule` is used as a **local feedback interface**, displaying:

- Uptime
    
- Sensor readings
    
- Wi-Fi connection status
    
- System states (e.g., "Waiting for pairing")
    

It also features a **message queue** to temporarily override the screen (e.g., ‚ÄúWater Low!‚Äù), giving real-time, offline feedback to users or technicians on-site.

---

### üõ† Control via AppContext

All major interactions are delegated to `AppContext`, which:

- Tracks and updates timers
    
- Executes fault logic
    
- Reads from sensors and dispatches MQTT
    
- Injects debug messages to LCD
    
- Enforces command routing and permission logic (e.g., only turn on pump if Wi-Fi connected)
    

This allows all firmware control logic to remain **centralized**, ensuring minimal bugs and race conditions between modules.