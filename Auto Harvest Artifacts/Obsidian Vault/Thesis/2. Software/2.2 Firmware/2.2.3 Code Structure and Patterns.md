The firmware for Auto Harvest is built around a **strictly layered and modular architecture**, enforcing separation of concerns between data acquisition, connectivity, control logic, and system configuration. Inspired by modern embedded systems and software architecture principles, the codebase promotes reusability, clarity, and flexibility.

### 🧱 Core Structural Layers

At its heart, the firmware is organized into the following component groups:

|Layer|Description|
|---|---|
|**Abstract**|Shared interfaces for all modules and sensors|
|**Sensors**|Individual drivers for pH, TDS, flow, temperature, humidity, etc.|
|**Modules**|Output devices like pumps, LCD, and Wi-Fi controller abstraction|
|**Services**|Infrastructure services like MQTT, EEPROM, Wi-Fi manager, LCD, etc.|
|**Utility**|Low-level tools (timers, string parsers, map formatters)|
|**App Context**|Central orchestrator that initializes, connects, and updates layers|

The entire flow is encapsulated in a `AppContext` class, which controls the system lifecycle.

---

### 📂 Directory Structure

Your `src/` folder is organized as follows:


`src/ ├── abstract/              # AbstractSensor, AbstractModule ├── context/               # AppContext singleton, main loop orchestrator ├── modules/               # Relays, LCD, air pump, water pump ├── sensors/               # Water level, temp, humidity, pH, TDS, flow ├── services/              # MQTT client, WiFi pairing logic, EEPROM manager ├── utility/               # Timers, request parsers, map helpers ├── main.cpp               # Entry point (delegates to AppContext)

This ensures that:

- **Each hardware feature** is implemented in isolation
    
- **Dependencies flow downward**, not across modules
    
- **Swapping components (e.g., from LCD1602 to OLED)** requires minimal change
    

---

### 💡 Object-Oriented Patterns

All sensors inherit from `AbstractSensor`, enforcing:

- `initialize()`
    
- `readData()` → returns `std::map<std::string, double>`
    
- `getStatusMessage()`, `getSensorName()`, `getType()`
    

Modules inherit from `AbstractModule`, and support:

- `initialize()`
    
- `setPower(bool)`
    
- `getStatus()`, `getName()`
    

This interface-driven approach allows:

- Hot-swapping modules (e.g., changing pump model)
    
- Parallel iteration through sensors/modules for polling or control
    
- Shared data containers (`MapWrapper`) for all sensor output
    

---

### 🔁 Main Loop Delegation

The Arduino `loop()` is clean and offloaded to `AppContext::loop()`. The main loop logic includes:



`if (sensorPollTimer.expired()) {     collector->readAllSensors(); } 
if (dataSendTimer.expired()) {     mqttClient->publishSensorData(currentData); } 
if (lcdUpdateTimer.expired()) {     lcd->updateScreen(); }`

Timers are non-blocking and keep the system responsive, even during Wi-Fi reconnects or MQTT queue bursts.

---

### 📋 Benefits of This Structure

- ✅ **Modular**: Add or remove sensors/modules with minimal changes
    
- ✅ **Testable**: Each service and hardware driver can be simulated or mocked
    
- ✅ **Scalable**: Can grow to support more sensors, devices, and control logic
    
- ✅ **Clean Loop**: Separates setup logic from periodic runtime behavior
    
- ✅ **Safe State Management**: Singleton `AppContext` keeps track of all system-wide state and resources