The code is structured around a **service-driven layered architecture**, built using Nx monorepo tooling. Every domain (users, controllers, logs) has a clear path:



`Route → Controller → Middleware (auth) → Service → Model`

Key services and their roles:

- **`collector.service.ts`**  
    Handles sensor log validation, type-based parsing, and insertion into MongoDB. Also performs **critical safety checks**, such as:
    
    - Detecting water flow mismatches when the pump is on
        
    - Emitting real-time shutdown commands
        
    - Logging the anomaly and notifying the user
        
- **`io.service.ts`**  
    Sets up and manages **WebSocket rooms per controller ID**, allowing subscribed clients to receive updates. It supports:
    
    - `new-log` event for live telemetry
        
    - `push-command` for backend-to-device actions
        
    - `info` messages for diagnostics or pairing
        
- **`expoPushNotification.service.ts`**  
    Sends push alerts to mobile users using **Expo’s push API**, triggered during fault states (e.g., pump failure). Handles:
    
    - Token validation
        
    - Error handling on push failure
        
    - Asynchronous delivery and logging
        

Each service is **stateless**, **reusable**, and separated from route logic — a design that simplifies testing and future scaling.