

To ensure secure and controlled access to resources within the Auto Harvest infrastructure, we employed Google Cloud's Identity and Access Management (IAM) system. This section outlines the role-based access strategies used for both automation and manual operations in our production environment.

#### 🛠️ Custom IAM Role: GitHub Actions Runner

A dedicated **custom IAM role** was created specifically for our CI/CD pipeline automation, named `GitHub Actions Runner`. This role is assigned to a service account used exclusively by GitHub Actions, and was crafted to provide just enough permission to:

- Manage Kubernetes workloads
    
- Handle container image operations
    
- Perform frontend cache invalidation
    
- Read/write/delete objects in Cloud Storage
    

Instead of assigning multiple predefined roles, we inherited permissions from the standard `Kubernetes Engine Admin` role and manually extended capabilities required for interacting with **Artifact Registry**, **Cloud Storage**, and **Google Compute Engine’s URL maps** (used for cache invalidation).

This granular approach avoids over-permissioning and keeps service accounts scoped to task-specific actions.

#### 🔐 Permissions Overview

The custom role includes fine-tuned permissions, such as:

- `container.clusters.*` for cluster operations
    
- `artifactregistry.*` for listing, uploading, and tagging Docker images
    
- `compute.urlMaps.invalidateCache` to clear CDN caches
    
- `storage.objects.*` for bucket interactions
    

This allowed the automation pipeline to deploy backend containers, upload new frontend builds, and invalidate stale cache entries post-deployment.

#### 👥 User Access and Role Assumption

For development and operations, we used our **personal Google accounts**. Admin actions—such as testing the runner’s permissions or manually triggering deployment steps—were executed via **service account impersonation**, using `gcloud` CLI. This provided a secure way to simulate the GitHub runner locally and verify pipeline behavior in a controlled environment.

#### 🔑 Authentication Method

We opted for the **classic key-based authentication** model over **Workload Identity Federation**, favoring simplicity and ease of integration with GitHub Actions. Although less secure in theory, this approach is acceptable in our case due to the single-cluster, single-repo nature of the prototype.

#### 🧪 Lessons from Configuration

IAM setup in GCP was generally smoother compared to other providers (e.g., AWS). However, some permissions were non-obvious — particularly those related to **URL map invalidation**, such as `compute.urlMaps.invalidateCache` and `compute.urlMaps.list`. These were necessary for enabling cache refreshes post-deployment and required manual discovery during testing.