The Auto Harvest infrastructure is designed around a **modular, secure, and cache-aware request flow**, built to handle both web-based client interactions and low-level MQTT communication from firmware devices. Cloudflare serves as the universal entrypoint, routing all incoming traffic based on subdomain, headers, and protocol.

#### ðŸ§­ General HTTP(S) Flow (Web & Mobile Clients)

For typical user interactions via the mobile app or web dashboard, the request flow is as follows:
Client (Web/Mobile)  
   â†“  
Cloudflare Edge Node (DNS, WAF, Cache)  
   â†“  
Header Rewrites (e.g., SPA route fallback, cache toggling)  
   â†“  
Google HTTPS Load Balancer  
   â†“  
Backend Service Target (API server in GKE or bucket)  
   â†“  
API or static response returned to client

This flow ensures:

- SSL/TLS encryption throughout (Cloudflare to GCP with Strict SSL)
    
- Smart caching or bypass depending on headers (`no-cache-baby`)
    
- WAF and bot filtering before backend resources are touched
    

#### ðŸ“¡ MQTT Request Flow (Firmware â†’ ActiveMQ)

Firmware communication follows a parallel but separate TCP-oriented flow:
Firmware Device  
   â†“  
DNS Resolution via Cloudflare  
   â†“  
Cloudflare TCP Proxy â†’ Google Load Balancer  
   â†“  
Kubernetes NodePort/Service â†’ ActiveMQ Pod  
   â†“  
Message processed and routed internally

This path is optimized for:

- Low-latency, stable MQTT delivery
    
- Load balancing via GCPâ€™s external TCP forwarding
    
- Isolation of ActiveMQ behind dedicated subdomains and ports
    

#### ðŸ”€ Flow Features & Optimizations

- **Dynamic routing**: Different subdomains route to isolated services (e.g., `api.` â†’ Express, `mqtt-` â†’ ActiveMQ)
    
- **Header rewriting**: Enables cache bypass and SPA behavior
    
- **Content-type awareness**: Ensures static files are cached, API responses are dynamic
    
- **No single entrypoint**: Services are decoupled to reduce complexity and attack surface