The Auto Harvest system is designed with a smooth and flexible local development process that allows developers to work on the frontend, backend, and firmware simultaneously.

#### **Frontend**

The mobile app is launched locally using the command `npx expo start`. Development is usually done directly on a physical mobile device using the **Expo Go** app, which allows fast reloading and testing. For builds that include native libraries, the team uses **internal distribution builds** to test the app in a more realistic environment.

To support development and debugging, tools such as **Redux DevTools** are used for tracking state changes, while **Expo Go** provides access to logs and real-time updates. The development environment does not require additional shortcuts or scripts, making it lightweight and easy to start.

#### **Backend**

The backend is developed within the Nx monorepo and is started using `npx nx serve api/report-server`, typically accessed through the plugin interface in Visual Studio Code. The backend service uses **Express.js**, and its dependencies, such as **MongoDB** and **ActiveMQ**, are run locally using **Docker**. This setup allows developers to quickly pull and run these services on any device without needing to install them directly.

Environment configuration files are not committed to version control but are safely shared through trusted channels among team members. This keeps sensitive information secure while maintaining consistent local setups across the team.

#### **Firmware**

Firmware development is handled using **PlatformIO**, where small C++ files are written and built for the **ATMEGA2560** microcontroller and **ESP-01** Wi-Fi module. The firmware is uploaded directly to the hardware from the IDE, and debugging is done using two main methods:

- **Serial Monitor**: Used to observe the program’s output and test communication with the backend.
    
- **LCD Display**: Used for physical debugging when real-time visual feedback is needed from the device itself.
    

Communication between the Arduino and backend is tested by observing both the Arduino’s serial output and the backend’s console logs. Additionally, the team uses the **ActiveMQ dashboard** to monitor and test message flow between devices and the server.

This local setup allows each part of the system—mobile app, server, and firmware—to be developed and tested independently, while still supporting full end-to-end testing when needed.